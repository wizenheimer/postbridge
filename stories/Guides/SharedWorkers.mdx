import { Meta } from '@storybook/blocks';

<Meta title="Guides/Shared Workers" />

# SharedWorker Guide

Complete guide to using postbridge with SharedWorkers for multi-tab communication and shared state.

## What are SharedWorkers?

SharedWorkers are special workers that can be **shared across multiple browser tabs, windows, or iframes** from the same origin. Unlike regular Web Workers (dedicated workers), a SharedWorker has a single instance that all pages can connect to.

**Key differences from Web Workers:**

| Feature | Web Worker | SharedWorker |
|---------|------------|--------------|
| **Scope** | Single page | Multiple pages/tabs |
| **Instances** | One per page | One shared instance |
| **Connection** | Direct | Via MessagePort |
| **Use case** | CPU-intensive tasks | Shared state, broadcasting |
| **Lifecycle** | Dies with page | Lives until all pages close |

**Use cases:**
- Shared application state across tabs
- Broadcasting updates to all tabs
- Centralized WebSocket connection
- Shared cache/database
- Cross-tab coordination
- Resource pooling

## Basic Setup

### 1. Create the SharedWorker

**shared-worker.js:**
```javascript
import { guest } from '@wizenheimer/postbridge';

// Track all connected tabs
const connections = new Map();
let nextTabId = 1;

// Handle new connections
self.onconnect = async (event) => {
  const port = event.ports[0];
  const tabId = `tab-${nextTabId++}`;

  console.log(`New connection: ${tabId}`);

  // Connect this port
  const connection = await guest.connect({
    // Methods that tabs can call
    registerTab: (tabInfo) => {
      connections.set(tabId, { ...tabInfo, port });
      console.log(`Registered ${tabId}:`, tabInfo);

      // Broadcast to all other tabs
      broadcastToOthers(tabId, {
        type: 'tab-joined',
        tabId,
        tabInfo
      });

      return {
        tabId,
        totalTabs: connections.size,
        tabs: Array.from(connections.entries()).map(([id, info]) => ({
          id,
          ...info
        }))
      };
    },

    unregisterTab: () => {
      connections.delete(tabId);
      console.log(`Unregistered ${tabId}`);

      broadcastToAll({
        type: 'tab-left',
        tabId
      });
    },

    broadcastMessage: (message) => {
      broadcastToAll({
        type: 'broadcast',
        from: tabId,
        message
      });
    },

    getConnectedTabs: () => {
      return Array.from(connections.entries()).map(([id, info]) => ({
        id,
        url: info.url,
        title: info.title
      }));
    },

    // Shared state
    setState: (key, value) => {
      sharedState.set(key, value);

      // Notify all tabs
      broadcastToAll({
        type: 'state-updated',
        key,
        value
      });
    },

    getState: (key) => {
      return sharedState.get(key);
    }
  }, {
    hostTarget: port,
    onConnectionSetup: async (remote) => {
      // Store remote for this tab
      connections.set(tabId, {
        ...connections.get(tabId),
        remote
      });
    }
  });

  port.start();

  // Cleanup when tab disconnects
  port.onmessageerror = () => {
    connections.delete(tabId);
    broadcastToAll({
      type: 'tab-left',
      tabId
    });
  };
};

// Shared state
const sharedState = new Map();

// Helper functions
function broadcastToAll(message) {
  connections.forEach(({ remote }) => {
    remote?.onBroadcast?.(message).catch(err =>
      console.error('Broadcast error:', err)
    );
  });
}

function broadcastToOthers(excludeTabId, message) {
  connections.forEach(({ remote }, tabId) => {
    if (tabId !== excludeTabId) {
      remote?.onBroadcast?.(message).catch(err =>
        console.error('Broadcast error:', err)
      );
    }
  });
}

console.log('SharedWorker initialized');
```

### 2. Connect from Multiple Tabs

**page.html (each tab):**
```html
<!DOCTYPE html>
<html>
<head>
  <title>SharedWorker Demo</title>
</head>
<body>
  <h1>Multi-Tab Communication</h1>

  <div id="tab-info">
    <h3>This Tab</h3>
    <p>Tab ID: <span id="tab-id">Connecting...</span></p>
    <p>Total Tabs: <span id="total-tabs">-</span></p>
  </div>

  <div id="connected-tabs">
    <h3>Connected Tabs</h3>
    <ul id="tabs-list"></ul>
  </div>

  <div id="messaging">
    <h3>Broadcast Message</h3>
    <input type="text" id="message-input" placeholder="Type a message...">
    <button id="send-btn">Send to All Tabs</button>
  </div>

  <div id="messages">
    <h3>Messages</h3>
    <ul id="messages-list"></ul>
  </div>

  <div id="shared-state">
    <h3>Shared State</h3>
    <input type="text" id="state-key" placeholder="Key">
    <input type="text" id="state-value" placeholder="Value">
    <button id="set-state-btn">Set State</button>
    <button id="get-state-btn">Get State</button>
    <pre id="state-display"></pre>
  </div>

  <script type="module" src="app.js"></script>
</body>
</html>
```

**app.js:**
```javascript
import { host } from '@wizenheimer/postbridge';

let myTabId = null;

async function init() {
  // Create SharedWorker
  const worker = new SharedWorker('shared-worker.js', { type: 'module' });

  // Connect via port
  const connection = await host.connect(worker.port, {
    // Methods the worker can call
    onBroadcast: (message) => {
      console.log('Broadcast received:', message);
      handleBroadcast(message);
    },

    log: (msg) => {
      console.log('[Worker]:', msg);
    }
  });

  // Start the port
  worker.port.start();

  // Register this tab
  const registration = await connection.remote.registerTab({
    url: window.location.href,
    title: document.title,
    timestamp: Date.now()
  });

  myTabId = registration.tabId;
  updateUI(registration);

  // Send message button
  document.getElementById('send-btn').addEventListener('click', async () => {
    const input = document.getElementById('message-input');
    const message = input.value.trim();

    if (message) {
      await connection.remote.broadcastMessage(message);
      input.value = '';

      // Show own message
      addMessage('You', message, true);
    }
  });

  // Set state button
  document.getElementById('set-state-btn').addEventListener('click', async () => {
    const key = document.getElementById('state-key').value;
    const value = document.getElementById('state-value').value;

    if (key && value) {
      await connection.remote.setState(key, value);
      console.log('State set:', key, '=', value);
    }
  });

  // Get state button
  document.getElementById('get-state-btn').addEventListener('click', async () => {
    const key = document.getElementById('state-key').value;

    if (key) {
      const value = await connection.remote.getState(key);
      document.getElementById('state-display').textContent =
        `${key} = ${JSON.stringify(value, null, 2)}`;
    }
  });

  // Refresh tabs list periodically
  setInterval(async () => {
    const tabs = await connection.remote.getConnectedTabs();
    updateTabsList(tabs);
  }, 2000);

  // Unregister on close
  window.addEventListener('beforeunload', () => {
    connection.remote.unregisterTab().catch(() => {});
  });

  console.log('Connected as', myTabId);
}

function updateUI(registration) {
  document.getElementById('tab-id').textContent = registration.tabId;
  document.getElementById('total-tabs').textContent = registration.totalTabs;
  updateTabsList(registration.tabs);
}

function updateTabsList(tabs) {
  const list = document.getElementById('tabs-list');
  list.innerHTML = '';

  tabs.forEach(tab => {
    const li = document.createElement('li');
    li.textContent = `${tab.id} - ${tab.title || tab.url}`;
    if (tab.id === myTabId) {
      li.style.fontWeight = 'bold';
      li.textContent += ' (you)';
    }
    list.appendChild(li);
  });
}

function handleBroadcast(message) {
  switch (message.type) {
    case 'tab-joined':
      addMessage('System', `${message.tabId} joined`, false, 'green');
      break;

    case 'tab-left':
      addMessage('System', `${message.tabId} left`, false, 'red');
      break;

    case 'broadcast':
      if (message.from !== myTabId) {
        addMessage(message.from, message.message, false);
      }
      break;

    case 'state-updated':
      console.log('State updated:', message.key, '=', message.value);
      break;
  }
}

function addMessage(from, text, isOwn, color = null) {
  const list = document.getElementById('messages-list');
  const li = document.createElement('li');
  li.textContent = `[${from}] ${text}`;

  if (isOwn) {
    li.style.fontStyle = 'italic';
  }
  if (color) {
    li.style.color = color;
  }

  list.appendChild(li);

  // Auto-scroll
  list.scrollTop = list.scrollHeight;
}

init().catch(console.error);
```

## Practical Examples

### Example 1: Shared WebSocket Connection

**shared-worker.js:**
```javascript
import { guest } from '@wizenheimer/postbridge';

let websocket = null;
const subscribers = new Map();

self.onconnect = async (event) => {
  const port = event.ports[0];
  const clientId = `client-${Date.now()}-${Math.random()}`;

  const connection = await guest.connect({
    subscribe: (channel) => {
      if (!subscribers.has(channel)) {
        subscribers.set(channel, new Set());
      }
      subscribers.get(channel).add(clientId);

      // Initialize WebSocket if not connected
      if (!websocket) {
        initWebSocket();
      }

      // Send subscription to server
      websocket?.send(JSON.stringify({
        type: 'subscribe',
        channel
      }));
    },

    unsubscribe: (channel) => {
      subscribers.get(channel)?.delete(clientId);

      websocket?.send(JSON.stringify({
        type: 'unsubscribe',
        channel
      }));
    },

    sendMessage: (channel, message) => {
      websocket?.send(JSON.stringify({
        type: 'message',
        channel,
        message
      }));
    }
  }, {
    hostTarget: port
  });

  // Store connection for broadcasting
  subscribers.set(clientId, { connection, port });

  port.start();

  // Cleanup on disconnect
  port.onmessageerror = () => {
    subscribers.delete(clientId);
  };
};

function initWebSocket() {
  websocket = new WebSocket('wss://example.com/socket');

  websocket.onopen = () => {
    console.log('WebSocket connected');
  };

  websocket.onmessage = (event) => {
    const data = JSON.parse(event.data);

    // Broadcast to subscribers
    const channelSubs = subscribers.get(data.channel);
    if (channelSubs) {
      channelSubs.forEach(clientId => {
        const client = subscribers.get(clientId);
        client?.connection?.remote?.onMessage?.(data);
      });
    }
  };

  websocket.onerror = (error) => {
    console.error('WebSocket error:', error);
  };

  websocket.onclose = () => {
    console.log('WebSocket closed');
    websocket = null;
  };
}
```

### Example 2: Shared Cache

**cache-worker.js:**
```javascript
import { guest } from '@wizenheimer/postbridge';

const cache = new Map();
const cacheTTL = new Map();

self.onconnect = async (event) => {
  const port = event.ports[0];

  await guest.connect({
    get: (key) => {
      // Check TTL
      if (cacheTTL.has(key)) {
        const ttl = cacheTTL.get(key);
        if (Date.now() > ttl) {
          cache.delete(key);
          cacheTTL.delete(key);
          return null;
        }
      }

      return cache.get(key);
    },

    set: (key, value, ttlSeconds = 300) => {
      cache.set(key, value);

      if (ttlSeconds > 0) {
        cacheTTL.set(key, Date.now() + (ttlSeconds * 1000));
      }

      return true;
    },

    delete: (key) => {
      cache.delete(key);
      cacheTTL.delete(key);
      return true;
    },

    clear: () => {
      cache.clear();
      cacheTTL.clear();
      return true;
    },

    keys: () => {
      return Array.from(cache.keys());
    },

    size: () => {
      return cache.size;
    }
  }, {
    hostTarget: port
  });

  port.start();
};

// Cleanup expired entries periodically
setInterval(() => {
  const now = Date.now();
  for (const [key, ttl] of cacheTTL.entries()) {
    if (now > ttl) {
      cache.delete(key);
      cacheTTL.delete(key);
    }
  }
}, 10000); // Every 10 seconds
```

**Usage in tabs:**
```javascript
const worker = new SharedWorker('cache-worker.js', { type: 'module' });
const connection = await host.connect(worker.port, {});
worker.port.start();

// Set value
await connection.remote.set('user', { id: 1, name: 'Alice' }, 60);

// Get value (works across all tabs)
const user = await connection.remote.get('user');
console.log(user); // { id: 1, name: 'Alice' }
```

### Example 3: Cross-Tab Notifications

**notification-worker.js:**
```javascript
import { guest } from '@wizenheimer/postbridge';

const tabs = new Map();

self.onconnect = async (event) => {
  const port = event.ports[0];
  const tabId = `tab-${Date.now()}-${Math.random()}`;

  const connection = await guest.connect({
    notify: ({ title, body, icon }) => {
      // Show notification to ALL tabs
      tabs.forEach(({ remote }, id) => {
        if (id !== tabId) {
          remote?.showNotification?.({ title, body, icon });
        }
      });
    },

    register: (tabInfo) => {
      tabs.set(tabId, { remote: connection.remote, info: tabInfo });
      return { tabId };
    }
  }, {
    hostTarget: port
  });

  tabs.set(tabId, { connection });

  port.start();

  // Cleanup
  port.onmessageerror = () => {
    tabs.delete(tabId);
  };
};
```

**Usage:**
```javascript
const worker = new SharedWorker('notification-worker.js', { type: 'module' });
const connection = await host.connect(worker.port, {
  showNotification: ({ title, body }) => {
    // Show notification in this tab
    new Notification(title, { body });
  }
});

worker.port.start();

// Register this tab
await connection.remote.register({
  url: window.location.href
});

// Send notification to all other tabs
await connection.remote.notify({
  title: 'New Message',
  body: 'You have a new message!',
  icon: '/icon.png'
});
```

## Key Differences from Web Workers

### Connection via MessagePort

```javascript
// Web Worker (direct connection)
const worker = new Worker('worker.js');
const connection = await host.connect(worker, {});

// SharedWorker (via port)
const sharedWorker = new SharedWorker('shared-worker.js');
const connection = await host.connect(sharedWorker.port, {});
sharedWorker.port.start(); // Must call start()!
```

### Multiple Connections in Worker

```javascript
// SharedWorker handles multiple connections
self.onconnect = async (event) => {
  const port = event.ports[0]; // Each connection has its own port

  // Create separate connection for this tab
  const connection = await guest.connect(schema, {
    hostTarget: port // Important: specify the port!
  });

  port.start();
};
```

### Lifecycle

```javascript
// Web Worker: Dies when page closes
// SharedWorker: Lives until ALL pages close

// Test: Open multiple tabs
// - Close one tab → SharedWorker still alive
// - Close all tabs → SharedWorker terminates
```

## Common Patterns

### Pattern 1: Tab Counter

```javascript
let tabCount = 0;

self.onconnect = async (event) => {
  tabCount++;
  console.log('Tab connected. Total:', tabCount);

  const port = event.ports[0];

  const connection = await guest.connect({
    getTabCount: () => tabCount
  }, { hostTarget: port });

  port.start();

  port.onmessageerror = () => {
    tabCount--;
    console.log('Tab disconnected. Total:', tabCount);
  };
};
```

### Pattern 2: Leader Election

```javascript
let leaderPort = null;

self.onconnect = async (event) => {
  const port = event.ports[0];

  const connection = await guest.connect({
    requestLeadership: () => {
      if (!leaderPort) {
        leaderPort = port;
        return true;
      }
      return false;
    },

    isLeader: () => {
      return port === leaderPort;
    }
  }, { hostTarget: port });

  port.start();

  port.onmessageerror = () => {
    if (port === leaderPort) {
      leaderPort = null;
    }
  };
};
```

### Pattern 3: Shared Task Queue

```javascript
const taskQueue = [];
const workers = new Map();

self.onconnect = async (event) => {
  const port = event.ports[0];
  const workerId = `worker-${Date.now()}`;

  const connection = await guest.connect({
    getNextTask: () => {
      return taskQueue.shift();
    },

    completeTask: (taskId, result) => {
      console.log('Task completed:', taskId);
      // Notify all tabs
      broadcastToAll({ type: 'task-complete', taskId, result });
    },

    addTask: (task) => {
      taskQueue.push(task);
      // Notify all tabs
      broadcastToAll({ type: 'task-added', task });
    }
  }, { hostTarget: port });

  workers.set(workerId, { connection, port });
  port.start();

  port.onmessageerror = () => {
    workers.delete(workerId);
  };
};
```

## Browser Compatibility

SharedWorkers are supported in:
-  Chrome 4+
-  Firefox 29+
-  Opera 10.6+
-  Safari (no support)
-  Edge 79+ (Chromium-based)

### Feature Detection

```javascript
if (typeof SharedWorker !== 'undefined') {
  // Use SharedWorker
  const worker = new SharedWorker('shared-worker.js');
  const connection = await host.connect(worker.port, {});
  worker.port.start();
} else {
  // Fallback to Web Worker
  console.warn('SharedWorker not supported, using Web Worker');
  const worker = new Worker('worker.js');
  const connection = await host.connect(worker, {});
}
```

## Debugging SharedWorkers

### Chrome DevTools

1. Open `chrome://inspect/#workers`
2. Find your SharedWorker
3. Click "inspect"
4. Use console, set breakpoints, etc.

### Console Logs

```javascript
// In SharedWorker
console.log('Log from SharedWorker');
// Appears in chrome://inspect/#workers inspector
```

### Terminating SharedWorker

SharedWorkers don't have a terminate() method. To stop:
1. Close all tabs using the worker
2. Or navigate to `chrome://inspect/#workers` and terminate manually

## Performance Considerations

### Memory Usage

SharedWorker memory is shared across all tabs:
```javascript
// Single instance for all tabs
const bigData = new Array(1000000); // Only one copy in memory
```

### Connection Overhead

Each tab has a separate connection:
```javascript
// 5 tabs = 5 connections
// Each connection has its own responseMap and handlers
```

### Broadcast Efficiency

```javascript
//  Slow: Call each tab individually
for (const tab of tabs) {
  await tab.remote.notify(message);
}

//  Fast: Fire-and-forget broadcast
tabs.forEach(tab => {
  tab.remote.notify(message).catch(console.error);
});
await Promise.all([...]) // If you need to wait
```

## Best Practices

1. **Always call port.start()** - Required for SharedWorker ports
2. **Handle disconnections** - Tabs can close anytime
3. **Clean up resources** - Remove tab from tracking on disconnect
4. **Use for shared state** - Not for CPU-intensive tasks
5. **Feature detection** - Safari doesn't support SharedWorkers
6. **Debug via chrome://inspect** - Regular DevTools won't show SharedWorker

## Summary

- **SharedWorkers** enable multi-tab communication
- **Single instance** shared across all tabs from same origin
- **Connection via MessagePort** with `worker.port`
- **Must call port.start()** to activate connection
- **postbridge handles** per-port connections automatically
- **Use cases:** Shared state, broadcasting, WebSocket pooling
- **Not supported** in Safari

**Next steps:**
- [Web Workers Guide](?path=/docs/guides-web-workers--docs) - Dedicated workers
- [Bidirectional RPC](?path=/docs/guides-bidirectional-rpc--docs) - Two-way communication
- [Examples](?path=/docs/examples-workers--docs) - More patterns
