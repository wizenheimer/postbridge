import { Meta } from '@storybook/blocks';

<Meta title="Guides/Bidirectional RPC" />

# Bidirectional RPC Guide

Complete guide to bidirectional RPC in postbridge - where both sides can call each other's methods.

## What is Bidirectional RPC?

In traditional RPC, communication is one-way: a **client** calls methods on a **server**. In bidirectional RPC, **both sides** are equal peers that can call each other's methods.

```
Traditional RPC (One-Way):
Client ────→ Server
       calls

Bidirectional RPC (Two-Way):
Host  ⇄  Guest
  ↓        ↑
calls   calls
  ↑        ↓
```

**Benefits:**
- **Callbacks**: Guest can report progress to host
- **Events**: Either side can notify the other
- **Coordination**: Both sides work together
- **Flexibility**: No rigid client/server roles

## How It Works

### The `remote` Parameter

Every method in your schema automatically receives a `remote` parameter as the **last argument**:

```javascript
const schema = {
  // Regular parameters + remote
  processData: async (data, remote) => {
    // remote = proxy to other side's methods
    await remote.log('Processing started');

    const result = process(data);

    await remote.log('Processing complete');

    return result;
  }
};
```

**The `remote` object:**
- Contains proxy functions for the other side's methods
- Same as `connection.remote` but passed directly
- Available in ALL methods automatically

## Basic Example

### Host Side

```javascript
import { host } from 'postbridge';

const worker = new Worker('worker.js', { type: 'module' });

const connection = await host.connect(worker, {
  // Host methods that worker can call
  log: (message) => {
    console.log('[Worker]:', message);
  },

  updateProgress: (current, total) => {
    const percent = ((current / total) * 100).toFixed(1);
    console.log(`Progress: ${percent}%`);
  },

  requestPermission: async (action) => {
    // Host can make decisions
    return confirm(`Allow worker to ${action}?`);
  }
});

// Host calls worker
const result = await connection.remote.processLargeDataset([...data]);
console.log('Result:', result);
```

### Guest Side

```javascript
import { guest } from 'postbridge';

const connection = await guest.connect({
  processLargeDataset: async (data, remote) => {
    // Guest calls host methods using remote parameter
    await remote.log('Starting processing...');

    const results = [];
    for (let i = 0; i < data.length; i++) {
      // Process item
      results.push(processItem(data[i]));

      // Report progress to host
      if (i % 100 === 0) {
        await remote.updateProgress(i, data.length);
      }
    }

    // Request permission before finishing
    const canFinish = await remote.requestPermission('save results');

    if (canFinish) {
      await remote.log('Processing complete!');
      return results;
    } else {
      throw new Error('Permission denied');
    }
  }
});
```

## Practical Examples

### Example 1: Progress Reporting

**Host:**
```javascript
const connection = await host.connect(worker, {
  onProgress: (percent) => {
    progressBar.style.width = `${percent}%`;
    progressBar.textContent = `${percent.toFixed(0)}%`;
  },

  onStatusChange: (status) => {
    statusText.textContent = status;
  }
});

await connection.remote.processFiles(files);
```

**Worker:**
```javascript
const connection = await guest.connect({
  processFiles: async (files, remote) => {
    await remote.onStatusChange('Initializing...');

    for (let i = 0; i < files.length; i++) {
      await remote.onStatusChange(`Processing ${files[i].name}...`);

      await processFile(files[i]);

      const percent = ((i + 1) / files.length) * 100;
      await remote.onProgress(percent);
    }

    await remote.onStatusChange('Complete!');
  }
});
```

### Example 2: Interactive Processing

**Host:**
```javascript
const connection = await host.connect(worker, {
  // Worker asks questions
  askQuestion: async (question, options) => {
    return new Promise(resolve => {
      const answer = prompt(`${question}\n\nOptions: ${options.join(', ')}`);
      resolve(answer);
    });
  },

  // Worker shows results
  showResult: (result) => {
    document.getElementById('result').textContent = JSON.stringify(result, null, 2);
  }
});

await connection.remote.interactiveProcess(data);
```

**Worker:**
```javascript
const connection = await guest.connect({
  interactiveProcess: async (data, remote) => {
    // Ask user how to process
    const method = await remote.askQuestion(
      'How should we process this data?',
      ['fast', 'accurate', 'balanced']
    );

    // Process based on answer
    const result = processWithMethod(data, method);

    // Show results
    await remote.showResult(result);

    return result;
  }
});
```

### Example 3: Streaming Data

**Host:**
```javascript
const chunks = [];

const connection = await host.connect(worker, {
  onDataChunk: (chunk) => {
    chunks.push(chunk);
    console.log(`Received chunk ${chunks.length}`);

    // Update UI with partial data
    updateChart(chunks);
  },

  onComplete: () => {
    console.log('All chunks received:', chunks.length);
  }
});

await connection.remote.streamLargeDataset();
```

**Worker:**
```javascript
const connection = await guest.connect({
  streamLargeDataset: async (remote) => {
    // Generate or fetch data in chunks
    for (let i = 0; i < 100; i++) {
      const chunk = generateChunk(i);

      // Send chunk to host
      await remote.onDataChunk(chunk);

      // Small delay to avoid overwhelming host
      await sleep(10);
    }

    await remote.onComplete();
  }
});

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

### Example 4: Bidirectional Event System

**Host:**
```javascript
const connection = await host.connect(worker, {
  // Host events
  onHostEvent: (event) => {
    console.log('Host event:', event);
  }
});

// Trigger worker events
document.getElementById('btn').addEventListener('click', async () => {
  await connection.remote.triggerEvent('button-clicked', { button: 'btn' });
});
```

**Worker:**
```javascript
const connection = await guest.connect({
  triggerEvent: async (eventName, data, remote) => {
    console.log('Worker received event:', eventName, data);

    // Process and send back to host
    await remote.onHostEvent({
      name: 'worker-processed',
      original: eventName,
      timestamp: Date.now()
    });
  }
});
```

### Example 5: Coordinated Work

**Host:**
```javascript
let currentPhase = 'idle';

const connection = await host.connect(worker, {
  getPhase: () => currentPhase,

  setPhase: (phase) => {
    currentPhase = phase;
    console.log('Phase changed to:', phase);
  },

  waitForPhase: async (targetPhase) => {
    // Wait for phase to match
    while (currentPhase !== targetPhase) {
      await sleep(100);
    }
  }
});

// Start work
await connection.remote.doCoordinatedWork();
```

**Worker:**
```javascript
const connection = await guest.connect({
  doCoordinatedWork: async (remote) => {
    // Wait for host to be ready
    await remote.setPhase('preparing');

    // Do preparation
    const prepared = prepare();

    // Signal ready
    await remote.setPhase('ready');

    // Wait for host confirmation
    await remote.waitForPhase('confirmed');

    // Proceed with work
    const result = doWork(prepared);

    // Signal complete
    await remote.setPhase('complete');

    return result;
  }
});
```

## Advanced Patterns

### Pattern 1: Pub/Sub System

**Host:**
```javascript
const subscribers = new Map();

const connection = await host.connect(worker, {
  subscribe: (topic, callback) => {
    if (!subscribers.has(topic)) {
      subscribers.set(topic, new Set());
    }
    subscribers.get(topic).add(callback);
  },

  publish: (topic, data) => {
    const subs = subscribers.get(topic);
    if (subs) {
      subs.forEach(callback => callback(data));
    }
  }
});

// Worker can subscribe and publish
```

**Worker:**
```javascript
const connection = await guest.connect({
  init: async (remote) => {
    // Subscribe to topics
    await remote.subscribe('data-update', (data) => {
      console.log('Data updated:', data);
    });

    // Publish to topics
    setInterval(() => {
      remote.publish('worker-heartbeat', { timestamp: Date.now() });
    }, 1000);
  }
});
```

### Pattern 2: Request/Response Ping-Pong

**Host:**
```javascript
const connection = await host.connect(worker, {
  ping: () => {
    console.log('Received ping');
    return 'pong';
  }
});

// Start ping-pong
const response = await connection.remote.startPingPong();
console.log('Final response:', response);
```

**Worker:**
```javascript
const connection = await guest.connect({
  startPingPong: async (remote) => {
    let count = 0;

    while (count < 10) {
      const response = await remote.ping();
      console.log('Received:', response);
      count++;

      await sleep(1000);
    }

    return 'Done!';
  }
});
```

### Pattern 3: Nested Callbacks

**Host:**
```javascript
const connection = await host.connect(worker, {
  processWithCallback: async (data, callback) => {
    // Process data
    const result = await someAsyncOperation(data);

    // Call the callback
    const transformed = await callback(result);

    return transformed;
  }
});

const result = await connection.remote.needsCallback({
  value: 42
});
```

**Worker:**
```javascript
const connection = await guest.connect({
  needsCallback: async (data, remote) => {
    // Pass our own callback to host
    return await remote.processWithCallback(data, async (processed) => {
      // This runs in worker, called by host!
      return processed * 2;
    });
  }
});
```

### Pattern 4: Mutual State Synchronization

**Host:**
```javascript
let hostState = { value: 0 };

const connection = await host.connect(worker, {
  getState: () => hostState,

  setState: (newState) => {
    hostState = newState;
    console.log('Host state updated:', hostState);
  },

  syncState: async () => {
    // Get worker state
    const workerState = await connection.remote.getState();

    // Merge states
    hostState = { ...hostState, ...workerState };

    // Send back to worker
    await connection.remote.setState(hostState);
  }
});

// Sync periodically
setInterval(() => {
  connection.remote.syncState();
}, 1000);
```

**Worker:**
```javascript
let workerState = { count: 0 };

const connection = await guest.connect({
  getState: () => workerState,

  setState: (newState) => {
    workerState = newState;
    console.log('Worker state updated:', workerState);
  },

  syncState: async (remote) => {
    // Get host state
    const hostState = await remote.getState();

    // Merge states
    workerState = { ...workerState, ...hostState };

    // Send back to host
    await remote.setState(workerState);
  }
});
```

## Error Handling in Bidirectional RPC

### Handling Remote Errors

```javascript
// Host
const connection = await host.connect(worker, {
  processWithValidation: (data) => {
    if (!isValid(data)) {
      throw new Error('Invalid data');
    }
    return process(data);
  }
});

// Worker
const connection = await guest.connect({
  doWork: async (remote) => {
    try {
      const result = await remote.processWithValidation(data);
      return result;
    } catch (error) {
      console.error('Host rejected data:', error.message);
      // Retry with corrected data
      return await remote.processWithValidation(correctData);
    }
  }
});
```

### Cascading Errors

```javascript
// Host
const connection = await host.connect(worker, {
  save: async (data) => {
    throw new Error('Save failed');
  }
});

// Worker
const connection = await guest.connect({
  process: async (data, remote) => {
    const result = processData(data);

    try {
      await remote.save(result);
    } catch (error) {
      // Host's error cascades to worker
      throw new Error(`Processing failed: ${error.message}`);
    }
  }
});

// Host call
try {
  await connection.remote.process(data);
} catch (error) {
  // Worker's error (which includes host's error) cascades back
  console.error(error.message);
  // "Processing failed: Save failed"
}
```

## Performance Considerations

### Minimize Round-Trips

```javascript
//  Slow: Multiple round-trips
for (const item of items) {
  await remote.validate(item);
  await remote.process(item);
  await remote.save(item);
}

//  Fast: Batch operations
const validated = await remote.validateBatch(items);
const processed = await remote.processBatch(validated);
await remote.saveBatch(processed);
```

### Fire-and-Forget vs Await

```javascript
// Await (blocks until complete)
await remote.log('message'); // Waits for log to complete

// Fire-and-forget (doesn't wait)
remote.log('message').catch(console.error); // Continues immediately
```

### Parallel Calls

```javascript
// Sequential (slow)
await remote.operation1();
await remote.operation2();
await remote.operation3();

// Parallel (fast)
await Promise.all([
  remote.operation1(),
  remote.operation2(),
  remote.operation3()
]);
```

## Debugging Tips

### Log RPC Calls

```javascript
const connection = await guest.connect({
  method: async (data, remote) => {
    console.log('→ Calling remote.hostMethod');
    const result = await remote.hostMethod(data);
    console.log('← Received result:', result);
    return result;
  }
});
```

### Track Call Chain

```javascript
let callDepth = 0;

const connection = await host.connect(worker, {
  hostMethod: async (data) => {
    const indent = '  '.repeat(callDepth++);
    console.log(`${indent}→ hostMethod called`);

    const result = await connection.remote.workerMethod(data);

    console.log(`${indent}← hostMethod returning`);
    callDepth--;

    return result;
  }
});
```

## Best Practices

1. **Use descriptive method names** - `onProgress`, `onComplete` make intent clear
2. **Handle errors gracefully** - Remote calls can fail
3. **Avoid infinite loops** - Don't create circular call chains
4. **Be mindful of latency** - Each call adds ~1-2ms
5. **Document callback patterns** - Make it clear what remote methods are available
6. **Use TypeScript** - Type safety prevents calling non-existent methods

## TypeScript Support

```typescript
interface HostSchema {
  log: (msg: string) => void;
  updateProgress: (current: number, total: number) => void;
}

interface GuestSchema {
  processData: (data: number[]) => Promise<number[]>;
}

// Type-safe remote parameter
const connection = await guest.connect<GuestSchema, HostSchema>({
  processData: async (data, remote) => {
    // remote is typed as HostSchema
    await remote.log('Processing...'); // 
    await remote.updateProgress(0, data.length); // 

    // TypeScript error:
    // await remote.nonExistent(); //  Error

    return data.map(x => x * 2);
  }
});
```

## Summary

- **Bidirectional RPC** lets both sides call each other
- **`remote` parameter** is automatically passed to all methods
- **Use for:** Progress reporting, callbacks, events, coordination
- **Performance:** Minimize round-trips, use batching
- **Type-safe** with TypeScript

**Common patterns:**
- Progress reporting
- Interactive workflows
- Streaming data
- Event systems
- State synchronization

**Next steps:**
- [Error Handling Guide](?path=/docs/guides-error-handling--docs)
- [Web Workers Guide](?path=/docs/guides-web-workers--docs)
- [Examples](?path=/docs/examples-workers--docs) - Real-world patterns
