import { Meta } from '@storybook/blocks';

<Meta title="API Reference/Connection" />

# Connection API Reference

Complete API reference for the Connection object returned by `host.connect()` and `guest.connect()`.

## Overview

The Connection object represents an established RPC connection between a host and guest. It provides access to remote methods and connection management.

```typescript
interface Connection<RemoteSchema = any> {
  id: string;
  remote: RemoteSchema;
  close: () => void;
}
```

## Properties

### id

Unique identifier for this connection.

**Type:** `string`

**Generated by:** Host during handshake

**Format:** `"{timestamp}-{random}"` (e.g., `"1699901234567-k2j5h3g8f"`)

**Examples:**
```javascript
const connection = await host.connect(worker, {});
console.log(connection.id); // "1699901234567-k2j5h3g8f"

// Use for logging
console.log(`[${connection.id}] Processing started`);

// Use for tracking
const connections = new Map();
connections.set(connection.id, connection);
```

**Use cases:**
- Logging and debugging
- Tracking multiple connections
- Identifying connections in errors
- Connection pooling

**Uniqueness:**
- Unique per connection
- Different for each `connect()` call
- Even same worker gets new ID if reconnected

```javascript
const conn1 = await host.connect(worker1, {});
const conn2 = await host.connect(worker2, {});

console.log(conn1.id !== conn2.id); // true
```

### remote

Proxy object containing remote methods that can be called.

**Type:** `RemoteSchema` (Generic type parameter)

**Contains:** Proxy functions for each method in the remote's schema

**All methods return Promises**, even if the original method is synchronous.

**Examples:**

#### Basic Usage

```javascript
const connection = await host.connect(worker, {});

// Call remote method
const result = await connection.remote.processData([1, 2, 3]);

// All calls are async
const sum = await connection.remote.calculateSum([1, 2, 3]);
```

#### With TypeScript

```typescript
interface GuestSchema {
  processData: (data: number[]) => Promise<number[]>;
  calculateSum: (numbers: number[]) => Promise<number>;
}

const connection = await host.connect<HostSchema, GuestSchema>(worker, {});

// Type-safe
const result: number[] = await connection.remote.processData([1, 2, 3]);
const sum: number = await connection.remote.calculateSum([1, 2, 3]);

// TypeScript errors
await connection.remote.unknownMethod(); //  Error
await connection.remote.processData("string"); //  Error
```

#### Nested Methods

```javascript
const connection = await host.connect(worker, {});

// Call nested methods
await connection.remote.math.add(5, 3);
await connection.remote.string.uppercase('hello');
await connection.remote.db.users.find({ active: true });
```

#### Error Handling

```javascript
try {
  const result = await connection.remote.riskyOperation();
} catch (error) {
  console.error('Remote method failed:', error);
  // Error thrown in remote method is caught here
}
```

#### Concurrent Calls

```javascript
// Multiple calls can be in flight simultaneously
const [result1, result2, result3] = await Promise.all([
  connection.remote.operation1(),
  connection.remote.operation2(),
  connection.remote.operation3()
]);
```

#### Fire-and-Forget

```javascript
// Don't wait for result
connection.remote.logMessage('Info').catch(console.error);

// Continue immediately
console.log('Message sent (not waiting for completion)');
```

**Important:**
- Always `await` remote calls
- Handle errors with try-catch
- Methods may take longer than expected (network/processing latency)
- Connection must be active (not closed)

### close()

Closes the connection and cleans up all resources.

**Type:** `() => void`

**Returns:** `void` (nothing)

**What it does:**
1. Removes connection from global connections map (host-side)
2. Removes all event listeners (handshake + RPC)
3. Clears response map (pending calls)
4. Clears local method handlers
5. Terminates worker (if guest is a Worker)

**Examples:**

#### Basic Cleanup

```javascript
const connection = await host.connect(worker, {});

// Use connection
await connection.remote.doWork();

// Clean up
connection.close();

// After close, connection is unusable
try {
  await connection.remote.doWork(); // May hang or error
} catch (error) {
  console.error('Connection closed:', error);
}
```

#### With Try-Finally

```javascript
const connection = await host.connect(worker, {});

try {
  const result = await connection.remote.processData(data);
  return result;
} catch (error) {
  console.error('Processing failed:', error);
  throw error;
} finally {
  // Always cleanup, even if error
  connection.close();
}
```

#### Conditional Cleanup

```javascript
let connection;

try {
  connection = await host.connect(worker, {});
  await connection.remote.doWork();
} finally {
  // Only close if connection was created
  connection?.close();
}
```

#### On Page Unload

```javascript
const connection = await host.connect(worker, {});

// Clean up when page closes
window.addEventListener('beforeunload', () => {
  connection.close();
});
```

#### Managing Multiple Connections

```javascript
const connections = [];

// Create connections
for (let i = 0; i < 4; i++) {
  const worker = new Worker('worker.js');
  const conn = await host.connect(worker, {});
  connections.push(conn);
}

// Close all
connections.forEach(conn => conn.close());
connections.length = 0;
```

**What happens to pending calls:**

```javascript
const connection = await host.connect(worker, {});

// Start long-running call
const promise = connection.remote.longTask();

// Close before it completes
connection.close();

// Promise behavior (implementation-specific):
// - May hang forever (no response)
// - May reject with error
// - May resolve if task completed before close

await promise; // Unpredictable
```

**Best practices:**
1. Always call `close()` when done
2. Use try-finally to ensure cleanup
3. Close on page unload
4. Close all connections in pools
5. Don't use connection after closing

**Performance impact:**
- Instant (no async work)
- Frees memory immediately
- Worker termination is async but non-blocking

## Usage Patterns

### Pattern 1: One-Shot Connection

```javascript
async function processInWorker(data) {
  const worker = new Worker('worker.js');
  const connection = await host.connect(worker, {});

  try {
    return await connection.remote.process(data);
  } finally {
    connection.close(); // Always cleanup
  }
}
```

### Pattern 2: Long-Lived Connection

```javascript
class WorkerService {
  constructor(workerScript) {
    this.workerScript = workerScript;
    this.connection = null;
  }

  async init() {
    const worker = new Worker(this.workerScript);
    this.connection = await host.connect(worker, {});
  }

  async process(data) {
    if (!this.connection) {
      throw new Error('Not initialized');
    }
    return await this.connection.remote.process(data);
  }

  close() {
    this.connection?.close();
    this.connection = null;
  }
}

// Usage
const service = new WorkerService('worker.js');
await service.init();

await service.process(data1);
await service.process(data2);
await service.process(data3);

service.close();
```

### Pattern 3: Connection Pool

```javascript
class ConnectionPool {
  constructor(workerScript, size) {
    this.workerScript = workerScript;
    this.size = size;
    this.available = [];
    this.all = [];
  }

  async init() {
    for (let i = 0; i < this.size; i++) {
      const worker = new Worker(this.workerScript);
      const conn = await host.connect(worker, {});

      this.all.push(conn);
      this.available.push(conn);
    }
  }

  async execute(method, ...args) {
    if (this.available.length === 0) {
      throw new Error('No available connections');
    }

    const conn = this.available.pop();

    try {
      return await conn.remote[method](...args);
    } finally {
      this.available.push(conn);
    }
  }

  close() {
    this.all.forEach(conn => conn.close());
    this.all = [];
    this.available = [];
  }

  get activeConnections() {
    return this.size - this.available.length;
  }

  get totalConnections() {
    return this.size;
  }
}
```

### Pattern 4: Connection Registry

```javascript
class ConnectionRegistry {
  constructor() {
    this.connections = new Map();
  }

  add(name, connection) {
    this.connections.set(name, connection);
  }

  get(name) {
    return this.connections.get(name);
  }

  remove(name) {
    const conn = this.connections.get(name);
    if (conn) {
      conn.close();
      this.connections.delete(name);
    }
  }

  closeAll() {
    this.connections.forEach(conn => conn.close());
    this.connections.clear();
  }

  list() {
    return Array.from(this.connections.entries()).map(([name, conn]) => ({
      name,
      id: conn.id
    }));
  }
}

// Usage
const registry = new ConnectionRegistry();

const worker1 = await host.connect(new Worker('w1.js'), {});
const worker2 = await host.connect(new Worker('w2.js'), {});

registry.add('worker1', worker1);
registry.add('worker2', worker2);

// Use by name
await registry.get('worker1').remote.doWork();

// Close all
registry.closeAll();
```

## TypeScript Definitions

```typescript
// Full type definition
interface Connection<RemoteSchema = any> {
  /**
   * Unique connection identifier
   * Format: "{timestamp}-{random}"
   */
  readonly id: string;

  /**
   * Proxy object for calling remote methods
   * All methods return Promises
   */
  readonly remote: RemoteSchema;

  /**
   * Closes connection and cleans up resources
   * - Removes event listeners
   * - Clears handlers
   * - Terminates worker (if applicable)
   */
  close(): void;
}

// Usage with types
interface GuestMethods {
  processData: (data: number[]) => Promise<number[]>;
  calculateSum: (numbers: number[]) => Promise<number>;
}

interface HostMethods {
  log: (message: string) => void;
  updateProgress: (percent: number) => void;
}

const connection: Connection<GuestMethods> = await host.connect<HostMethods, GuestMethods>(
  worker,
  {
    log: (message) => console.log(message),
    updateProgress: (percent) => console.log(`${percent}%`)
  }
);

// Type-safe remote calls
const result: number[] = await connection.remote.processData([1, 2, 3]);
const sum: number = await connection.remote.calculateSum([1, 2, 3]);
```

## Comparison with Other Patterns

### Connection vs Direct postMessage

```javascript
//  Direct postMessage (complex)
worker.postMessage({ action: 'process', data: [1, 2, 3] });
worker.addEventListener('message', (event) => {
  if (event.data.action === 'result') {
    console.log(event.data.result);
  }
});

//  Connection (simple)
const result = await connection.remote.process([1, 2, 3]);
console.log(result);
```

### Multiple Connections vs Single Worker

```javascript
//  Single worker with manual routing
worker.postMessage({ id: 1, method: 'task1' });
worker.postMessage({ id: 2, method: 'task2' });
// Need to manually match responses...

//  Multiple connections (automatic routing)
const conn1 = await host.connect(worker1, {});
const conn2 = await host.connect(worker2, {});
await conn1.remote.task1();
await conn2.remote.task2();
// Automatic response matching!
```

## See Also

- [host.connect()](?path=/docs/api-reference-host-api--docs) - Creating connections from host
- [guest.connect()](?path=/docs/api-reference-guest-api--docs) - Creating connections from guest
- [Connection Lifecycle](?path=/docs/architecture-lifecycle--docs) - Detailed lifecycle
- [Web Workers Guide](?path=/docs/guides-web-workers--docs) - Worker patterns
