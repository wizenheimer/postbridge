import { Meta } from '@storybook/blocks';

<Meta title="Examples/Image Processing" />

# Image Processing with Web Workers

This example demonstrates using postbridge to offload image processing to a Web Worker, keeping the UI responsive during CPU-intensive operations.

## Overview

**What it does:**
- Loads an image from a file or canvas
- Sends image data to worker for processing
- Applies filters (grayscale, invert, blur) without blocking UI
- Uses transferables for efficient data transfer
- Shows real-time progress updates

**Technologies:**
- postbridge for worker communication
- Canvas API for image manipulation
- File API for image loading
- Transferable objects for performance

## Complete Code

### index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Processor with postbridge</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .container {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }

    .canvas-container {
      flex: 1;
    }

    canvas {
      max-width: 100%;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
    }

    button:hover {
      background: #0056b3;
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .progress {
      height: 30px;
      background: #f0f0f0;
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: #28a745;
      width: 0%;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }

    .info {
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>Ô∏è Image Processor with Web Workers</h1>
  <p>Upload an image and apply filters using postbridge-powered Web Workers</p>

  <input type="file" id="file-input" accept="image/*">

  <div class="container">
    <div class="canvas-container">
      <h3>Original</h3>
      <canvas id="original-canvas"></canvas>
    </div>

    <div class="canvas-container">
      <h3>Processed</h3>
      <canvas id="processed-canvas"></canvas>
    </div>
  </div>

  <div class="controls">
    <button id="grayscale-btn">Grayscale Filter</button>
    <button id="invert-btn">Invert Colors</button>
    <button id="blur-btn">Blur (3x3)</button>
    <button id="sharpen-btn">Sharpen</button>

    <div class="progress">
      <div class="progress-bar" id="progress-bar">0%</div>
    </div>

    <div class="info" id="info">
      Load an image to get started
    </div>
  </div>

  <script type="module" src="main.js"></script>
</body>
</html>
```

### main.js

```javascript
import { host, withTransferable } from 'postbridge';

// DOM elements
const fileInput = document.getElementById('file-input');
const originalCanvas = document.getElementById('original-canvas');
const processedCanvas = document.getElementById('processed-canvas');
const grayscaleBtn = document.getElementById('grayscale-btn');
const invertBtn = document.getElementById('invert-btn');
const blurBtn = document.getElementById('blur-btn');
const sharpenBtn = document.getElementById('sharpen-btn');
const progressBar = document.getElementById('progress-bar');
const info = document.getElementById('info');

let connection = null;
let currentImageData = null;

// Initialize worker
async function initWorker() {
  const worker = new Worker('image-worker.js', { type: 'module' });

  connection = await host.connect(worker, {
    // Host methods that worker can call
    updateProgress: (percent) => {
      progressBar.style.width = `${percent}%`;
      progressBar.textContent = `${percent.toFixed(0)}%`;
    },

    log: (message) => {
      console.log('[Worker]:', message);
    }
  });

  info.textContent = ' Worker initialized and ready';
}

// Load image file
fileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  info.textContent = `Loading ${file.name}...`;

  const img = new Image();
  img.onload = () => {
    // Draw to original canvas
    originalCanvas.width = img.width;
    originalCanvas.height = img.height;
    const ctx = originalCanvas.getContext('2d');
    ctx.drawImage(img, 0, 0);

    // Store image data
    currentImageData = ctx.getImageData(0, 0, img.width, img.height);

    // Setup processed canvas
    processedCanvas.width = img.width;
    processedCanvas.height = img.height;

    // Enable buttons
    grayscaleBtn.disabled = false;
    invertBtn.disabled = false;
    blurBtn.disabled = false;
    sharpenBtn.disabled = false;

    info.textContent = ` Loaded ${img.width}x${img.height} image`;
  };

  img.src = URL.createObjectURL(file);
});

// Apply filter
async function applyFilter(filterType) {
  if (!currentImageData) {
    alert('Please load an image first');
    return;
  }

  // Disable buttons during processing
  const buttons = [grayscaleBtn, invertBtn, blurBtn, sharpenBtn];
  buttons.forEach(btn => btn.disabled = true);

  info.textContent = `Applying ${filterType} filter...`;
  progressBar.style.width = '0%';
  progressBar.textContent = '0%';

  const startTime = performance.now();

  try {
    // Create copy of buffer to transfer
    const buffer = currentImageData.data.buffer.slice(0);

    // Process in worker with transferable
    const result = await connection.remote.applyFilter(
      withTransferable(t => ({
        data: t(buffer),
        width: currentImageData.width,
        height: currentImageData.height,
        filter: filterType
      }))
    );

    // Display processed image
    const processedData = new ImageData(
      new Uint8ClampedArray(result.data),
      result.width,
      result.height
    );

    const ctx = processedCanvas.getContext('2d');
    ctx.putImageData(processedData, 0, 0);

    const elapsed = (performance.now() - startTime).toFixed(2);
    info.textContent = ` ${filterType} applied in ${elapsed}ms`;

  } catch (error) {
    info.textContent = ` Error: ${error.message}`;
    console.error(error);
  } finally {
    // Re-enable buttons
    buttons.forEach(btn => btn.disabled = false);
    progressBar.style.width = '100%';
    progressBar.textContent = '100%';
  }
}

// Button handlers
grayscaleBtn.addEventListener('click', () => applyFilter('grayscale'));
invertBtn.addEventListener('click', () => applyFilter('invert'));
blurBtn.addEventListener('click', () => applyFilter('blur'));
sharpenBtn.addEventListener('click', () => applyFilter('sharpen'));

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  connection?.close();
});

// Initialize
initWorker();
```

### image-worker.js

```javascript
import { guest, withTransferable } from 'postbridge';

// Connect to host
const connection = await guest.connect({
  // Worker method to apply image filters
  applyFilter: async ({ data, width, height, filter }, remote) => {
    await remote.log(`Starting ${filter} filter on ${width}x${height} image`);

    const pixels = new Uint8ClampedArray(data);
    const totalPixels = width * height;
    let processedPixels = 0;

    // Apply selected filter
    switch (filter) {
      case 'grayscale':
        for (let i = 0; i < pixels.length; i += 4) {
          const avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
          pixels[i] = avg;     // R
          pixels[i + 1] = avg; // G
          pixels[i + 2] = avg; // B
          // pixels[i + 3] is alpha (unchanged)

          // Update progress every 10000 pixels
          if (++processedPixels % 10000 === 0) {
            const percent = (processedPixels / totalPixels) * 100;
            await remote.updateProgress(percent);
          }
        }
        break;

      case 'invert':
        for (let i = 0; i < pixels.length; i += 4) {
          pixels[i] = 255 - pixels[i];       // R
          pixels[i + 1] = 255 - pixels[i + 1]; // G
          pixels[i + 2] = 255 - pixels[i + 2]; // B

          if (++processedPixels % 10000 === 0) {
            const percent = (processedPixels / totalPixels) * 100;
            await remote.updateProgress(percent);
          }
        }
        break;

      case 'blur':
        // Simple 3x3 box blur
        const original = new Uint8ClampedArray(pixels);
        for (let y = 1; y < height - 1; y++) {
          for (let x = 1; x < width - 1; x++) {
            for (let c = 0; c < 3; c++) { // RGB only
              const i = (y * width + x) * 4 + c;

              // 3x3 kernel
              const sum = (
                original[i - width * 4 - 4] + original[i - width * 4] + original[i - width * 4 + 4] +
                original[i - 4]            + original[i]            + original[i + 4] +
                original[i + width * 4 - 4] + original[i + width * 4] + original[i + width * 4 + 4]
              );

              pixels[i] = sum / 9;
            }

            if (++processedPixels % 10000 === 0) {
              const percent = (processedPixels / totalPixels) * 100;
              await remote.updateProgress(percent);
            }
          }
        }
        break;

      case 'sharpen':
        // Simple sharpen kernel
        const orig = new Uint8ClampedArray(pixels);
        for (let y = 1; y < height - 1; y++) {
          for (let x = 1; x < width - 1; x++) {
            for (let c = 0; c < 3; c++) {
              const i = (y * width + x) * 4 + c;

              // Sharpen kernel: [0,-1,0], [-1,5,-1], [0,-1,0]
              const value = (
                orig[i] * 5 -
                orig[i - 4] -
                orig[i + 4] -
                orig[i - width * 4] -
                orig[i + width * 4]
              );

              pixels[i] = Math.max(0, Math.min(255, value));
            }

            if (++processedPixels % 10000 === 0) {
              const percent = (processedPixels / totalPixels) * 100;
              await remote.updateProgress(percent);
            }
          }
        }
        break;
    }

    await remote.updateProgress(100);
    await remote.log(`Completed ${filter} filter`);

    // Return processed image (transfer back for efficiency)
    return withTransferable(t => ({
      data: t(pixels.buffer),
      width,
      height
    }));
  }
});

console.log('Image worker ready!');
```

## How It Works

### 1. Worker Initialization

```javascript
const worker = new Worker('image-worker.js', { type: 'module' });
const connection = await host.connect(worker, {
  updateProgress: (percent) => { /* update UI */ },
  log: (message) => { /* log to console */ }
});
```

The main thread creates a worker and connects with host methods for progress updates and logging.

### 2. Image Loading

```javascript
const img = new Image();
img.onload = () => {
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  currentImageData = ctx.getImageData(0, 0, img.width, img.height);
};
img.src = URL.createObjectURL(file);
```

Image is loaded into a canvas, and `ImageData` is extracted for processing.

### 3. Filter Application

```javascript
const buffer = currentImageData.data.buffer.slice(0);

const result = await connection.remote.applyFilter(
  withTransferable(t => ({
    data: t(buffer),
    width: currentImageData.width,
    height: currentImageData.height,
    filter: 'grayscale'
  }))
);
```

Image data is transferred to worker for processing. Using `withTransferable` makes this very fast for large images.

### 4. Progress Updates

```javascript
// In worker
if (++processedPixels % 10000 === 0) {
  const percent = (processedPixels / totalPixels) * 100;
  await remote.updateProgress(percent);
}
```

Worker calls back to main thread to update progress bar during processing.

### 5. Display Results

```javascript
const processedData = new ImageData(
  new Uint8ClampedArray(result.data),
  result.width,
  result.height
);
ctx.putImageData(processedData, 0, 0);
```

Processed image data is displayed on the canvas.

## Key Concepts Demonstrated

### Transferable Objects

```javascript
withTransferable(t => ({
  data: t(buffer),  // Transferred (zero-copy)
  width,            // Copied
  height            // Copied
}))
```

The large image buffer is transferred (not copied), making this very fast even for high-resolution images.

### Bidirectional RPC

```javascript
// Main thread calls worker
await connection.remote.applyFilter(imageData);

// Worker calls main thread (inside method)
async applyFilter(data, remote) {
  await remote.updateProgress(50);
}
```

Both sides can call each other's methods.

### Progress Reporting

Worker reports progress periodically:
- Every 10,000 pixels processed
- Final 100% when complete
- Keeps UI responsive and informed

## Performance

**Without transferables (copying):**
- 1920x1080 image (8MB): ~500ms transfer time
- Total time: ~1000ms

**With transferables (zero-copy):**
- 1920x1080 image (8MB): ~1ms transfer time
- Total time: ~500ms

**50% faster with transferables!**

## Extending This Example

### Add More Filters

```javascript
case 'sepia':
  for (let i = 0; i < pixels.length; i += 4) {
    const r = pixels[i];
    const g = pixels[i + 1];
    const b = pixels[i + 2];

    pixels[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
    pixels[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
    pixels[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
  }
  break;
```

### Worker Pool for Batch Processing

```javascript
const pool = new WorkerPool('image-worker.js', schema, 4);

const results = await Promise.all(
  images.map(img => pool.execute('applyFilter', img))
);
```

### Save Processed Image

```javascript
processedCanvas.toBlob((blob) => {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'processed-image.png';
  a.click();
});
```

## Summary

This example demonstrates:
-  Offloading CPU-intensive work to workers
-  Using transferables for performance
-  Bidirectional communication for progress updates
-  Real-world image processing use case
-  Keeping UI responsive during heavy computation

**Key takeaway:** With postbridge, worker communication feels like regular function calls, even when doing complex bidirectional communication with transferables!
